基于 ECMAScript 2025 规范（第 16 版），JavaScript（ECMAScript）的核心语法与语义构建在一个严密的逻辑体系之上，涵盖了从底层的词法分析到高层的对象行为和执行模型。

以下是对其核心语法与语义的详细解析：

### 1. 语法体系：词法与句法 (Grammars)

规范将语言的解析过程分为两个主要阶段，分别由不同的文法定义：

- **词法文法 (Lexical Grammar)：** 定义了如何将源代码（Unicode 代码点序列）转换为**输入元素（Input Elements）**，即 Tokens、行终止符、注释和空白符。
    - **自动分号插入 (ASI)：** 这是一个关键的语法特性。当解析器遇到无法解析的 token 流时，会在特定条件下（如行尾、`}` 前）自动插入分号以尝试修复解析,。
- **句法文法 (Syntactic Grammar)：** 定义了 Tokens 如何组成**语法产生式 (Productions)**，如表达式、语句和声明。解析的目标符号通常是 `Script` 或 `Module`。

### 2. 类型系统 (Data Types)

ECMAScript 的类型系统分为两类：直接在语言中操作的**语言类型**和用于描述算法行为的**规范类型**。

- **ECMAScript 语言类型：** 开发者直接使用的值。
    
    - **Undefined & Null：** 分别表示未赋值和故意的空值。
    - **Boolean：** 逻辑真与假。
    - **String：** UTF-16 代码单元序列。
    - **Symbol：** 唯一且不可变的原始值，常用于对象属性键。
    - **Number：** IEEE 754-2019 双精度浮点数。
    - **BigInt：** 任意精度的整数，不能与 Number 隐式互转,。
    - **Object：** 属性的集合。
- **规范类型 (Specification Types)：** 这些是“元值”，仅存在于规范算法中，用于描述语义，开发者无法直接访问。
    
    - **Reference Record（引用记录）：** 用于解释赋值、`delete`、`typeof` 等操作。它包含 `[[Base]]`（基值）和 `[[ReferencedName]]`（名称），是左值表达式求值的结果。
    - **Completion Record（完成记录）：** 用于解释控制流（如 `break`、`return`、`throw`）。它包含 `[[Type]]`（如 NORMAL, THROW）、`[[Value]]` 和 `[[Target]]`。
    - **Environment Record（环境记录）：** 用于解析标识符绑定。

### 3. 执行架构 (Execution Architecture)

JS 的运行依赖于一套复杂的执行状态管理机制。

- **执行上下文 (Execution Contexts)：** 任何时刻，每个 Agent（代理）至多有一个正在运行的执行上下文。上下文包含特定状态，如 **Realm**（领域，包含全局对象和内建对象）、**Function**（当前执行的函数对象）以及 **ScriptOrModule**,。
- **环境记录 (Environment Records)：** 构成了作用域链的基础。
    - **声明式环境记录 (Declarations)：** 用于 `var`、`const`、`let`、`class`、`function` 等声明。
    - **对象环境记录 (Object)：** 将标识符绑定关联到对象的属性（如 `with` 语句或全局环境的一部分）,。
- **作业 (Jobs) 与微任务：** 规范定义了 `Job`（即通常所说的微任务）来处理异步操作（如 Promise 的回调）。宿主环境通过 `HostEnqueuePromiseJob` 等钩子调度这些作业。

### 4. 对象模型 (Object Model)

ECMAScript 是基于对象的，通过**内部方法 (Internal Methods)** 和 **内部槽 (Internal Slots)** 定义行为。

- **基本对象语义：** 所有对象（Ordinary Objects）都必须支持一组**基本内部方法**，如 `[[Get]]`、`[[Set]]`、`[[Delete]]`、`[[Call]]`（如果是函数）等,。
    - 例如，访问属性 `obj.prop` 实际上是调用了 `[[Get]]` 内部方法。
- **原型继承 (Prototype Chain)：** 对象拥有 `[[Prototype]]` 内部槽。当访问不存在的属性时，会沿着原型链向上查找，直到找到或遇到 `null`,。
- **异质对象 (Exotic Objects)：** 某些对象（如 Array、Proxy）覆盖了默认的内部方法以实现特殊行为。例如，Array 的 `length` 属性会在添加元素时自动更新。

### 5. 核心语义操作

- **类型转换 (Type Conversion)：** 语言定义了抽象操作如 `ToNumber`、`ToBoolean`、`ToPrimitive` 来处理隐式转换。例如，`ToPrimitive` 会尝试调用对象的 `valueOf` 或 `toString` 方法,。
- **比较操作：**

### 6. 函数与类 (Functions and Classes)

- **函数对象：** 函数是可调用的对象，拥有 `[[Call]]` 内部方法。如果是构造函数，还拥有 `[[Construct]]` 方法。
- **this 绑定：** 取决于函数的调用方式。箭头函数没有自己的 `this`，它使用词法作用域中的 `this`,。
- **类 (Classes)：** 类定义是严格模式代码。`class` 语法实际上是定义构造函数和原型的语法糖，但提供了更清晰的继承声明（`extends`）和 `super` 访问机制,。

### 7. 脚本与模块 (Scripts and Modules)

- **脚本 (Scripts)：** 代码在全局范围内运行，顶级声明会成为全局对象的属性（如果使用 `var` 或 `function`）。
- **模块 (Modules)：** 自动处于严格模式。模块拥有独立的 **Module Environment Record**。它们通过 `import` 和 `export` 静态地定义依赖关系，并在执行前进行链接（Linking）,。
    - 模块记录包含 `[[Status]]`（如 `LINKED`, `EVALUATED`）以管理循环依赖和异步加载。

### 8. 严格模式 (Strict Mode)

严格模式是语言的一个变体，通过限制某些语法（如禁用 `with`）和改变语义（如未声明变量赋值抛错而非创建全局变量）来提供更安全的代码环境。类定义和模块代码默认就是严格模式,。


